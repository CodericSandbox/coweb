//
// Exposing the operation engine as a standalone API (separate from OCW).
//
// Copyright (c) The Dojo Foundation 2011. All Rights Reserved.
// Copyright (c) IBM Corporation 2008, 2011. All Rights Reserved.
//
/*jslint white:false, bitwise:true, eqeqeq:true, immed:true, nomen:false,
  onevar:false, plusplus:false, undef:true, browser:true, devel:true,
  forin:false, sub:false*/
/*global define*/
define([
	"dojo",
	"coweb/jsoe/OperationEngine",
], function(dojo, OperationEngine) {

	if ("undefined" === typeof console) {
		var noop = function() {};
		console = {};
		console.error =
		console.warn =
		console.log =
		console.info =
		console.debug = noop;
	}

	/** TODO
	  */
	var OTEngine = function(id) {
		this._engine = new OperationEngine(id);
		this._engine.freezeSite(id);
		this._engineStable = true;
	};

	var proto = OTEngine.prototype;

	/**
	  * @return context vector to send to the server, or false on error
	  */
	proto.syncOutbound = function() {
		if (!this._engine || !this._engineStable)
			return false;
		return this._engine.copyContextVector();
	};

	/**
	  * @param site from site
	  * @param sites remote sites context vector
	  * @return whether or not local engine was synced
	  */
	proto.syncInbound = function(site, sites) {
		// Ignore our own engine syncs.
		if (site == this._engine.siteId)
			return false;
		try {
			this._engine.pushSyncWithSites(site, sites);
		} catch (e) {
			console.warn("OTEngine: failed to receive engine sync ", site, sites, e);
			return false;
		}
		return true;
	};

	/**
	  * Attempts to purge the OT engine.
	  *
	  * @return whether or not the engine was purged
	  */
	proto.purge = function() {
		if (!this._engine || !this._engineStable)
			return false;
		try {
			this._engine.purge();
		} catch (e) {
			console.warn("OTEngine: failed to purge engine " + e.message);
			return false;
		}
		return true;
	};

	/** TODO
	  */
	proto.isStable = function() {
		return this._engineStable;
	}

	/** TODO
	  */
	proto.createOp = function(topic, value, type, position) {
		if (undefined === type)
			type = "update";
		if (undefined === position)
			position = 0;
		return {
			topic: topic,
			value: value,
			type: type,
			position: position
		};
	};

	/**
	  * Call this after the local document has applied a local operation.
	  *
	  * @param topic
	  * @param localOp
	  * @return JSON encodable object to send to remote sites, or false on error.
	  */
	// TODO does null type even make sense?
	proto.localEvent = function(topic, localOp) {
		// if the mutex is held, we're broadcasting and shouldn't be
		// getting any additional events back, EVER!
		// (all other events will be generated by the same broadcast
		// at other locations so we NEVER have to ship them)
		// assumes synchronous hub operation
		// stop now if we have no engine
		// TODO wtf???
		if (this._mutex) {
			return false;
		}

		if (!this._engineStable) {
			return false;
		}

		// unpack event data; be sure to json encode the value before pushing
		// into op engine to avoid ref sharing with the operation history
		var position = localOp.position,
			type = localOp.type,
			value = JSON.stringify(localOp.value),
			op = null,
			sites = null,
			msg,
			sent,
			err;

		if (type !== null) {
			// build operation
			try {
				op = this._engine.createOp(true, topic, value, type, position);
				sites = op.contextVector.sites;
			} catch(e) {
				console.error('OTEngine::localEvent: bad type "' + type +
					'" on outgoing event. OperationEngine unchanged.');
				return false;
			}
		}

		// add local event to engine, but only if it was really sent
		// yes, the local state changed, but it's better to keep the
		// context vector in the engine consistent than to track an
		// event we never sent
		this._engine.pushLocalOp(op);
		// we have to allow purges after sending even one event in
		// case this site is the only one in the session for now
		this._shouldPurge = true;

		// Construct and return the JSON object that client will send to remote server.
		return {
			topic: topic,
			value: value,
			type: type,
			position: position,
			site: this._engine.siteId,
			sites: sites,
		};
	};

	/**
	  * Call this when a remote site wants to synchronize an operation. The
	  * scenario is that a remote site ferries an operation to this local site,
	  * then this local site must transform the operation to one that can be
	  * applied locally (maintaining consistency).
	  *
	  * @param remoteOp remote operation to be transformed
	  * @param order Total order seen by all collaborators.
	  * @return transformed event that can safely be applied to the local document
	  */
	proto.remoteEvent = function(remoteOp, order) {
		return this._syncInbound(remoteOp.topic, remoteOp.value, remoteOp.type,
				remoteOp.position, remoteOp.site, remoteOp.sites, order);
	};

	/**
	 * Called by the session when a coweb event is received from a remote app.
	 * Processes the data in the local operation engine if required before
	 * publishing it on the local Hub.
	 *
	 * @param {String} topic Topic name (topics.SYNC.**)
	 * @param {String} value JSON-encoded operation value
	 * @param {String|null} type Operation type
	 * @param {Number} position Operation linear position
	 * @param {Number} site Unique integer ID of the sending site
	 * @param {Number[]} sites Context vector as an array of integers
	 * @param {Number} order Total order seen by all collaborators.
	 */
	proto._syncInbound = function(topic, value, type, position, site, sites, order) {
		var op, event;

		// check if the event has a context and non-null type
		if (sites && type) {
			// treat event as a possibly conflicting operation
			try {
				op = this._engine.push(false, topic, value, type, position,
					site, sites, order);
			} catch(e) {
				console.log("topic ",topic);
				console.log("value ",value);
				console.log("type ",type);
				console.log("position ",position);
				console.warn("OTEngine: failed to push op into engine " + e.message);
				// TODO what should be done?
				this._engineStable = false;
				return false;
			}
			// discard null operations; they should not be sent to app
			// according to op engine
			if(op === null) {return;}
			// use newly computed value and position
			value = op.value;
			position = op.position;
		} else if(site === this._engine.siteId) {
			// op was echo'ed from server for op engine, but type null means
			// op engine doesn't care about this message anyway so drop it
			return;
		}

		// value is always json-encoded to avoid ref sharing problems with ops
		// stored inside the op engine history buffer, so decode it and
		// pack it into a hub event
		event = {
			position : position,
			type : type,
			value : JSON.parse(value),
			site : site
		};

		// publish on local hub
		/*this._mutex = true;
		try {
			OpenAjax.hub.publish(topic, event);
		} catch(z) {
			console.warn('UnmanagedHubListener: failed to deliver incoming event ' +
				topic + '(' + z.message + ')');
		}
		this._mutex = false;
		*/

		if (op) {
			// we've gotten an operation from elsewhere, so we should sync
			// and/or purge the engine on the next interval
			this._shouldPurge = true;
			this._shouldSync = true;
		}
		return event;
	};

	return OTEngine;
});
